var Notes = (function () {

    var NOTES = [['A', 'As', 'B', 'C', 'Cs', 'D', 'Ds', 'E', 'F', 'Fs', 'G', 'Gs'], ['A', 'Bf', 'B', 'C', 'Df', 'D', 'Ef', 'E', 'F', 'Gf', 'G', 'Af']],
        NOTES_NAME = [['A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#'], ['A', 'Bb', 'B', 'C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab']],

        SCALE_NAME = [
            'Cromatic Scale',
            'Major Scale',
            'Minor Scale',
          //  'Harmonic Major',
          //  'Harmonic Minor',
            'Melodic Major Scale',
            'Melodic Minor Scale',
            'Pentatonic Major Scale',
            'Pentatonic Minor Scale',
            'Blues Scale'
        ],

        INTERVALS_SCALE = [
            //cromatic
            [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],

            //Major
            [0, 2, 2, 1, 2, 2, 2, 1],
            // Minor
            [0, 2, 1, 2, 2, 1, 2, 2],

            // Harmonic major TODO CORRECT
            //[0, 2, 2, 1, 2, 1, 2, 3],
            // Harmonic Minor
          //  [0, 2, 1, 2, 2, 1, 3, 1],

            // melodic major
            [0, 2, 2, 1, 2, 1,2, 2],

            // melodic Minor
            [0, 2, 1, 2, 2, 2, 2, 2],

            // Major  pentatonic
            [0, 2, 2, 3 , 2, 3],
            // pentatonic Minor
            [0, 3, 2, 2 ,3 , 2],

            // blues
            [0, 3, 2, 1, 1, 3, 2],
        ],
        SCALE = {
            names:  SCALE_NAME,
            intervals: INTERVALS_SCALE,
        },

        _way_to_show_notes = 0,

        _notes_from_tonic_classes = [],

        _notes_from_tonic_name = [],

        THE_SCALE = [];


    /*
    --------------------------------------
    TO POPULATE SELECT
    --------------------------------------
    */

    var getNotes = function () {
        return NOTES_NAME[_way_to_show_notes];
    };

    var getModes = function () {
        return MODES;
    };

    var getScaleName = function () {
        return SCALE;
    };


    /*
    --------------------------------------
    GET THE SCALE STARTING FROM THE TONIC NOTE
    --------------------------------------
    */

    var getNotesFromTonic = function (interval) {

        return slideToTheRightTonic(interval);

    };

    function slideToTheRightTonic(int) {

        var notes_from_tonic_note_classes = NOTES[_way_to_show_notes].slice(0),
            notes_from_tonic_note_name = NOTES_NAME[_way_to_show_notes].slice(0);

        for (var i = 0; i < int; i++) {
            var classe = notes_from_tonic_note_classes.shift();
            notes_from_tonic_note_classes.push(classe);

            var name = notes_from_tonic_note_name.shift();
            notes_from_tonic_note_name.push(name);
        }

        _notes_from_tonic_classes = notes_from_tonic_note_classes;
        _notes_from_tonic_name = notes_from_tonic_note_name;


        return {
            names: _notes_from_tonic_name,
            classes: _notes_from_tonic_classes
        };
    }


    /*
    --------------------------------------
    GET THE SCALE WE WANT
    --------------------------------------
    */

    var getScale = function (intervals) {
        var single_interval = 0;

        THE_SCALE = [];

        for (var i = 0; i < intervals.length - 1; i++) {
            single_interval += intervals[i];

            if (_notes_from_tonic_classes === []) {

                THE_SCALE.push(NOTES[single_interval]);

            }
            else {

                THE_SCALE.push(_notes_from_tonic_classes[single_interval]);

            }
        }

        return THE_SCALE;
    };

    return {
        getNotes: getNotes,
        getModes: getModes,
        getScaleName: getScaleName,
        getScale: getScale,
        getNotesFromTonic: getNotesFromTonic
    };

})();
;var showMeScalesApp = (function () {

    var tonic,
        scale,
        instrument_to_play,

        Guitar = {
            name: 'guitar',
            strings: [0, 7, 0, 5, 10, 2, 7],
            number: 22,
            inlays: 10
        },

        Bass_5_strings = {
            name: 'bass',
            strings: [0, 7, 0, 5, 10, 0],
            number: 20,
            inlays: 9
        },
        /*
        Bass_4_strings = {
            name: '4 Strings Bass',
            strings: [0, 7, 0, 5,  0],
            number: 20,
            inlays: 9
        },

        Ukulele = {
            name: 'Ukulele',
            strings: [0, 10, 4, 7,  0, 0],
            number: 18,
            inlays: 9
        },
        */
        instruments_Available = [Guitar,
                                 Bass_5_strings//,
                                 // Bass_5_strings,
                                 // Ukulele
        ],

        drawInstrument = function (i) {
            instrument_to_play = instruments_Available[i];
            Instrument.draw(instrument_to_play);
        },

        drawTonic = function (i) {
            tonic = Notes.getNotesFromTonic(i).classes[0];
            Instrument.drawTonic(tonic);
        };


    return {
        instruments: instruments_Available,
        drawInstrument: drawInstrument,
        drawTonic: drawTonic
    };


})();
;/**
 * selectFx.js v1.0.0
 * http://www.codrops.com
 *
 * Licensed under the MIT license.
 * http://www.opensource.org/licenses/mit-license.php
 * 
 * Copyright 2014, Codrops
 * http://www.codrops.com
 */
( function( window ) {
	
	'use strict';



	/**
	 * based on from https://github.com/inuyaksa/jquery.nicescroll/blob/master/jquery.nicescroll.js
	 */
	function hasParent( e, p ) {
		if (!e) return false;
		var el = e.target||e.srcElement||e||false;
		while (el && el != p) {
			el = el.parentNode||false;
		}
		return (el!==false);
	}
	
	/**
	 * extend obj function
	 */
	function extend( a, b ) {
		for( var key in b ) { 
			if( b.hasOwnProperty( key ) ) {
				a[key] = b[key];
			}
		}
		return a;
	}

	/**
	 * SelectFx function
	 */
	function SelectFx( el, options ) {	
		this.el = el;
		this.options = extend( {}, this.options );
		extend( this.options, options );
		this._init();
	}

	/**
	 * SelectFx options
	 */
	SelectFx.prototype.options = {
		// if true all the links will open in a new tab.
		// if we want to be redirected when we click an option, we need to define a data-link attr on the option of the native select element
		newTab : true,
		// when opening the select element, the default placeholder (if any) is shown
		stickyPlaceholder : true,
		// callback when changing the value
		onChange : function( val ) { return false; }
	};

	/**
	 * init function
	 * initialize and cache some vars
	 */
	SelectFx.prototype._init = function() {
		// check if we are using a placeholder for the native select box
		// we assume the placeholder is disabled and selected by default
		var selectedOpt = this.el.querySelector( 'option[selected]' );
		this.hasDefaultPlaceholder = selectedOpt && selectedOpt.disabled;

		// get selected option (either the first option with attr selected or just the first option)
		this.selectedOpt = selectedOpt || this.el.querySelector( 'option' );

		// create structure
		this._createSelectEl();

		// all options
		this.selOpts = [].slice.call( this.selEl.querySelectorAll( 'li[data-option]' ) );
		
		// total options
		this.selOptsCount = this.selOpts.length;
		
		// current index
		this.current = this.selOpts.indexOf( this.selEl.querySelector( 'li.cs-selected' ) ) || -1;
		
		// placeholder elem
		this.selPlaceholder = this.selEl.querySelector( 'span.cs-placeholder' );

		// init events
		this._initEvents();
	};

	/**
	 * creates the structure for the select element
	 */
	SelectFx.prototype._createSelectEl = function() {
		var self = this, options = '', createOptionHTML = function(el) {
			var optclass = '', classes = '', link = '';

			if( el.selectedOpt && !this.foundSelected && !this.hasDefaultPlaceholder ) {
				classes += 'cs-selected ';
				this.foundSelected = true;
			}
			// extra classes
			if( el.getAttribute( 'data-class' ) ) {
				classes += el.getAttribute( 'data-class' );
			}
			// link options
			if( el.getAttribute( 'data-link' ) ) {
				link = 'data-link=' + el.getAttribute( 'data-link' );
			}

			if( classes !== '' ) {
				optclass = 'class="' + classes + '" ';
			}

			return '<li ' + optclass + link + ' data-option data-value="' + el.value + '"><span>' + el.textContent + '</span></li>';
		};

		[].slice.call( this.el.children ).forEach( function(el) {
			if( el.disabled ) { return; }

			var tag = el.tagName.toLowerCase();

			if( tag === 'option' ) {
				options += createOptionHTML(el);
			}
			else if( tag === 'optgroup' ) {
				options += '<li class="cs-optgroup"><span>' + el.label + '</span><ul>';
				[].slice.call( el.children ).forEach( function(opt) {
					options += createOptionHTML(opt);
				} );
				options += '</ul></li>';
			}
		} );

		var opts_el = '<div class="cs-options"><ul>' + options + '</ul></div>';
		this.selEl = document.createElement( 'div' );
		this.selEl.className = this.el.className;
		this.selEl.tabIndex = this.el.tabIndex;
		this.selEl.innerHTML = '<span class="cs-placeholder">' + this.selectedOpt.textContent + '</span>' + opts_el;
		this.el.parentNode.appendChild( this.selEl );
		this.selEl.appendChild( this.el );
	};

	/**
	 * initialize the events
	 */
	SelectFx.prototype._initEvents = function() {
		var self = this;

		// open/close select
		this.selPlaceholder.addEventListener( 'click', function() {
			self._toggleSelect();
		} );

		// clicking the options
		this.selOpts.forEach( function(opt, idx) {
			opt.addEventListener( 'click', function() {
				self.current = idx;
				self._changeOption();
				// close select elem
				self._toggleSelect();
			} );
		} );

		// close the select element if the target it´s not the select element or one of its descendants..
		document.addEventListener( 'click', function(ev) {
			var target = ev.target;
			if( self._isOpen() && target !== self.selEl && !hasParent( target, self.selEl ) ) {
				self._toggleSelect();
			}
		} );

		// keyboard navigation events
		this.selEl.addEventListener( 'keydown', function( ev ) {
			var keyCode = ev.keyCode || ev.which;

			switch (keyCode) {
				// up key
				case 38:
					ev.preventDefault();
					self._navigateOpts('prev');
					break;
				// down key
				case 40:
					ev.preventDefault();
					self._navigateOpts('next');
					break;
				// space key
				case 32:
					ev.preventDefault();
					if( self._isOpen() && typeof self.preSelCurrent != 'undefined' && self.preSelCurrent !== -1 ) {
						self._changeOption();
					}
					self._toggleSelect();
					break;
				// enter key
				case 13:
					ev.preventDefault();
					if( self._isOpen() && typeof self.preSelCurrent != 'undefined' && self.preSelCurrent !== -1 ) {
						self._changeOption();
						self._toggleSelect();
					}
					break;
				// esc key
				case 27:
					ev.preventDefault();
					if( self._isOpen() ) {
						self._toggleSelect();
					}
					break;
			}
		} );
	};

	/**
	 * navigate with up/dpwn keys
	 */

	SelectFx.prototype._navigateOpts = function(dir) {
		if( !this._isOpen() ) {
			this._toggleSelect();
		}

		var tmpcurrent = typeof this.preSelCurrent != 'undefined' && this.preSelCurrent !== -1 ? this.preSelCurrent : this.current;
		
		if( dir === 'prev' && tmpcurrent > 0 || dir === 'next' && tmpcurrent < this.selOptsCount - 1 ) {
			// save pre selected current - if we click on option, or press enter, or press space this is going to be the index of the current option
			this.preSelCurrent = dir === 'next' ? tmpcurrent + 1 : tmpcurrent - 1;
			// remove focus class if any..
			this._removeFocus();
			// add class focus - track which option we are navigating
			classie.add( this.selOpts[this.preSelCurrent], 'cs-focus' );
		}
	};

	/**
	 * open/close select
	 * when opened show the default placeholder if any
	 */

	SelectFx.prototype._toggleSelect = function() {
		// remove focus class if any..
		this._removeFocus();
		
		if( this._isOpen() ) {
			if( this.current !== -1 ) {
				// update placeholder text
				this.selPlaceholder.textContent = this.selOpts[ this.current ].textContent;
			}
			classie.remove( this.selEl, 'cs-active' );
		}
		else {
			if( this.hasDefaultPlaceholder && this.options.stickyPlaceholder ) {
				// everytime we open we wanna see the default placeholder text
				this.selPlaceholder.textContent = this.selectedOpt.textContent;
			}
			classie.add( this.selEl, 'cs-active' );
		}
	};

	/**
	 * change option - the new value is set
	 */

	SelectFx.prototype._changeOption = function() {
		// if pre selected current (if we navigate with the keyboard)...
		if( typeof this.preSelCurrent != 'undefined' && this.preSelCurrent !== -1 ) {
			this.current = this.preSelCurrent;
			this.preSelCurrent = -1;
		}

		// current option
		var opt = this.selOpts[ this.current ];

		// update current selected value
		this.selPlaceholder.textContent = opt.textContent;
		


		// remove class cs-selected from old selected option and add it to current selected option
		var oldOpt = this.selEl.querySelector( 'li.cs-selected' );
		if( oldOpt ) {
			classie.remove( oldOpt, 'cs-selected' );
		}
		classie.add( opt, 'cs-selected' );

		// if there´s a link defined
		if( opt.getAttribute( 'data-link' ) ) {
			// open in new tab?
			if( this.options.newTab ) {
				window.open( opt.getAttribute( 'data-link' ), '_blank' );
			}
			else {
				window.location = opt.getAttribute( 'data-link' );
			}
		}

		// callback
		this.options.onChange( this.current );

		Select.setValue(this.el.className, this.current);
	};

	/**
	 * returns true if select element is opened
	 */

	SelectFx.prototype._isOpen = function(opt) {
		return classie.has( this.selEl, 'cs-active' );
	};

	/**
	 * removes the focus class from the option
	 */

	SelectFx.prototype._removeFocus = function(opt) {
		var focusEl = this.selEl.querySelector( 'li.cs-focus' );
		if( focusEl ) {
			classie.remove( focusEl, 'cs-focus' );
		}
	};

	/**
	 * add to global namespace
	 */
	window.SelectFx = SelectFx;

} )( window );
;var Select = (function () {


    //VARS
    var _selection = document.querySelector(".selection .container"),
        instrument_to_play = '',
        tonic = '';


    // CREATE THE ELEMENTS
    fillSelectWithContent('Show me the', 'scales', Notes.getScaleName().names);
    fillSelectWithContent('Show me tonic', 'notes', Notes.getNotes());
    fillSelectWithContent('Show me the', 'playinginstrument', showMeScalesApp.instruments);

    [].slice.call(document.querySelectorAll('.select')).forEach(function (el) {
        new SelectFx(el,
            {
                onChange: function (val) {
                    return true;
                }
            }
        );
    });


    function fillSelectWithContent(text, name, content) {

        var box = document.createElement('div');


        //set the description of selection

        var paragraph = document.createElement('p');
        paragraph.className = 'text';
        paragraph.innerHTML = text;

        //set the select

        var select = document.createElement('select');

        select.className = 'select ' + name;

        var placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.disabled = true;
        placeholder.selected = true;
        select.appendChild(placeholder);


        if (name === 'scales') {
            placeholder.innerHTML = 'scale';
            box.className = 'box scales disabled';
        }
        if (name === 'notes') {
            placeholder.innerHTML = 'note';
            box.className = 'box notes disabled';
        }
        if (name === 'playinginstrument') {
            placeholder.innerHTML = 'instrument';
            box.className = 'box playinginstrument';
        }

        for (var i = 0; i < content.length; i++) {

            var opt = document.createElement('option');
            opt.value = content[i];
            opt.innerHTML = content[i];

            if (name === 'playinginstrument') {
                opt.value = content[i].name;
                opt.innerHTML = content[i].name;
            }

            select.appendChild(opt);
        }

        box.appendChild(paragraph);
        box.appendChild(select);
        _selection.appendChild(box);
    }

    function setValue(el, val) {

        if (el.indexOf('playinginstrument') !== -1) {
            setInstrument(val);
        }
        if (el.indexOf('note') !== -1) {
            setTonic(val);
        }
        if (el.indexOf('scales') !== -1) {
            setScale(val);
        }

    }

    function setInstrument(obj) {

        // just once
        if (instrument_to_play === '') {
            var sel = _selection.querySelector('.box.playinginstrument p');
            sel.innerHTML = 'on ';
            var notes = _selection.querySelector('.box.notes');
            notes.className = 'box notes';
        }

        instrument_to_play = obj;
        showMeScalesApp.drawInstrument(instrument_to_play);
    }


    function setTonic(note) {

        // just once
        if (tonic === '') {
            var sel = _selection.querySelector('.box.notes p');
            sel.innerHTML = 'of tonic';
            var notes = _selection.querySelector('.box.scales');
            notes.className = 'box scales';
        }

        tonic = note;
        showMeScalesApp.drawTonic(tonic);

        // Instrument.getTonic(;
    }

    function setScale(index) {

        scale_index = index;

        var intervals = Notes.getScaleName().intervals[scale_index];
        var scale = Notes.getScale(intervals);
        Instrument.highlight(scale);
        console.log(intervals + '  |  ' + scale);
    }

    return {
        setValue: setValue
    };

})();;var Instrument = (function () {

    var _instrument = document.querySelector(".instrument .container"),
        _interval_semitones = 0;

    var drawFretboard = function (Instrument) {
        var obj = Instrument;
        renderIt(obj);
    };

    function renderIt(object) {

        var obj = object,
            _fretboard = document.createElement('div'),
            note_name = [],
            note_class = [];

        for (var i = 0; i < obj.strings.length; i++) {

            var _step = document.createElement('div'),
                notes = Notes.getNotesFromTonic(obj.strings[i]);

            _step.className = 'string';

            note_name = notes.names;
            note_class = notes.classes;

            for (var j = 0; j < obj.number; j++) {

                _interval_semitones++;

                if (_interval_semitones > note_class.length - 1) {
                    resetInterval();
                }


                    var _semitone = document.createElement('div');
                    _semitone.className = 'note ' + note_class[_interval_semitones];
                    if (i !== 0) {
                    var _p = document.createElement('p');
                    _p.innerHTML = note_name[_interval_semitones];

                    _semitone.appendChild(_p);
                    }
                    _step.appendChild(_semitone);
                }


            resetInterval();

            if (_fretboard.firstChild === null) {
                _fretboard.appendChild(_step);
            }
            else {
                _fretboard.insertBefore(_step, _fretboard.firstChild);
            }


        }

        for (var b = 0; b < obj.inlays; b++) {
            var _inlay = document.createElement('div');
            _inlay.className = 'inlays';
            _fretboard.appendChild( _inlay);

            _fretboard.insertBefore(_inlay, _fretboard.firstChild);
        }

        _fretboard.className = 'fretboard ' + obj.name;
        _instrument.appendChild(_fretboard);

    }

    function resetInterval() {
        _interval_semitones = 0;
        return _interval_semitones;
    }

    var paintTonic = function (tonic) {
        PaintNotes( 'tonic', tonic );
    };

    var paintScales = function (notesOfScale) {
        PaintNotes( 'highlighted', notesOfScale );
    };

    function PaintNotes ( classNameToPaint, toHighlight ){

        var removeNotes = _instrument.querySelectorAll('.' + classNameToPaint),
            reg = new RegExp('(\\s|^)' + classNameToPaint + '(\\s|$)');

        for (var a = 0; a < removeNotes.length; a++) {
            removeNotes[a].className = removeNotes[a].className.replace(reg, ' ');
        }

        for (var z = 1; z < toHighlight.length; z++) {

            var notes_name = toHighlight,
                notes = _instrument.querySelectorAll('.' + notes_name),
                typeOfNote = " " + classNameToPaint;

            for (var i = 0; i < notes.length; i++) {

                notes[i].className += typeOfNote;
            }
        }
    }

    return {
        draw: drawFretboard,
        drawTonic: paintTonic,
        drawScales: paintScales
    };


})();;/*!
 * classie - class helper functions
 * from bonzo https://github.com/ded/bonzo
 * 
 * classie.has( elem, 'my-class' ) -> true/false
 * classie.add( elem, 'my-new-class' )
 * classie.remove( elem, 'my-unwanted-class' )
 * classie.toggle( elem, 'my-class' )
 */

/*jshint browser: true, strict: true, undef: true */
/*global define: false */

( function( window ) {

'use strict';

// class helper functions from bonzo https://github.com/ded/bonzo

function classReg( className ) {
  return new RegExp("(^|\\s+)" + className + "(\\s+|$)");
}

// classList support for class management
// altho to be fair, the api sucks because it won't accept multiple classes at once
var hasClass, addClass, removeClass;

if ( 'classList' in document.documentElement ) {
  hasClass = function( elem, c ) {
    return elem.classList.contains( c );
  };
  addClass = function( elem, c ) {
    elem.classList.add( c );
  };
  removeClass = function( elem, c ) {
    elem.classList.remove( c );
  };
}
else {
  hasClass = function( elem, c ) {
    return classReg( c ).test( elem.className );
  };
  addClass = function( elem, c ) {
    if ( !hasClass( elem, c ) ) {
      elem.className = elem.className + ' ' + c;
    }
  };
  removeClass = function( elem, c ) {
    elem.className = elem.className.replace( classReg( c ), ' ' );
  };
}

function toggleClass( elem, c ) {
  var fn = hasClass( elem, c ) ? removeClass : addClass;
  fn( elem, c );
}

var classie = {
  // full names
  hasClass: hasClass,
  addClass: addClass,
  removeClass: removeClass,
  toggleClass: toggleClass,
  // short names
  has: hasClass,
  add: addClass,
  remove: removeClass,
  toggle: toggleClass
};

// transport
if ( typeof define === 'function' && define.amd ) {
  // AMD
  define( classie );
} else {
  // browser global
  window.classie = classie;
}

})( window );
